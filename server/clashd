#!/usr/bin/python3

import asyncio
import json
import secrets
import traceback

from aiohttp import web, WSMsgType


class ClashServer():

    def __init__(self):
        self.app = web.Application()
        self.app["websockets"] = set()
        self.app.router.add_get("/clash", self.master_handler)
        self.app.router.add_get("/clash/{session}", self.slave_handler)
        self.app.on_shutdown.append(self.on_shutdown)
        self.sessions = {}

    def run(self):
        web.run_app(self.app)

    async def master_handler(self, request):
        print("master: connected")
        session_ws = web.WebSocketResponse()
        await session_ws.prepare(request)

        session_id = secrets.token_urlsafe(6)
        await session_ws.send_json({"session": session_id})
        self.sessions[session_id] = (session_ws, [])

        while True:
            try:
                msg = await session_ws.receive()
                if msg.type == WSMsgType.CLOSE or msg.type == WSMsgType.CLOSED:
                    break
                elif msg.type == WSMsgType.ERROR:
                    break
                elif msg.type == WSMsgType.TEXT:
                    try:
                        data = json.loads(msg.data)
                    except Exception:
                        self.log(traceback.format_exc())
                        continue

                    to = None
                    if "header" in data:
                        if "to" in data["header"]:
                            to = data["header"]["to"]
                        del data["header"]

                    if to is not None:
                        if to < len(self.sessions[session_id][1])):
                            self.sessions[session_id][1][to].send_str(json.dumps(data))
                    else:
                        for slave_ws in self.sessions[session_id][1]:
                            # print(f"master -> slave: {msg.data}")
                            await slave_ws.send_str(json.dumps(data))
            except asyncio.CancelledError:
                pass

        return session_ws

    async def slave_handler(self, request):
        session_id = request.match_info["session"]
        if session_id not in self.sessions:
            return False
        master_ws = self.sessions[session_id][0]
        print(f"slave: connected to session {session_id}")
        slave_ws = web.WebSocketResponse()
        await slave_ws.prepare(request)

        self.sessions[session_id][1].append(slave_ws)

        while True:
            try:
                msg = await slave_ws.receive()
                if msg.type == WSMsgType.CLOSE or msg.type == WSMsgType.CLOSED:
                    break
                elif msg.type == WSMsgType.ERROR:
                    break
                elif msg.type == WSMsgType.TEXT:
                    # print(f"master -> slave: {msg.data}")
                    try:
                        data = json.loads(msg.data)
                    except Exception:
                        self.log(traceback.format_exc())
                        continue
                    data["header"] = {}
                    data["header"]["from"] = self.sessions[session_id][1].index(slave_ws)

                    await master_ws.send_str(msg.data)

            except asyncio.CancelledError:
                pass

        return slave_ws

    async def on_shutdown(self):
        for task in self.app["websockets"]:
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass


if __name__ == "__main__":
    clashd = ClashServer()
    clashd.run()
